[
{"slide_number": 0, "content": "Topic: Excellenteam - \n\nExcellenteam is the name of an organization, company, or team. Without additional context, it is unclear what their exact purpose or focus is. \n\nTopic: C++ \n\nC++ is a programming language known for its speed, efficiency, and versatility. It is commonly used in developing large-scale software systems, such as operating systems, video games, and high-performance applications. \n\nTopic: \u05de\u05e6\u05d2\u05ea 4 \n\n\"\u05de\u05e6\u05d2\u05ea 4\" is likely referring to a presentation or slide deck created for a specific purpose. Without context or additional information, the subject matter of this presentation is unclear. \n\nTopic: \u05d9\u05e8\u05d5\u05e9\u05d4 \u05d5\u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd \n\n\"\u05d9\u05e8\u05d5\u05e9\u05d4 \u05d5\u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd\" is a Hebrew phrase that translates to \"inheritance and polymorphism.\" In the context of programming, it likely refers to the concepts of inheritance and polymorphism in object-oriented programming (OOP). \n\nTopic: \u05de\u05db\u05d5\u05df \u05dc\u05d1, \u05ea\u05e9\u05e4\"\u05d2 \n\n\"\u05de\u05db\u05d5\u05df \u05dc\u05d1\" translates to \"Lev Institute\" and \"\u05ea\u05e9\u05e4\"\u05d2\" is likely a Hebrew year. Without more information, it is unclear what the relevance of this topic is to the other topics mentioned."},
{"slide_number": 1, "content": "The bullet points of the presentation are as follows:\n\n1. \u05de\u05d8\u05e8\u05d5\u05ea \u05d7\u05d6\u05e8\u05d4 \u05de\u05e7\u05d9\u05e4\u05d4 \u05e2\u05dc \u05e0\u05d5\u05e9\u05d0\u05d9\u05dd \u05d1\u05e9\u05e4\u05ea C++: This topic is about revisiting the key concepts of C++ programming language.\n\n2. \u05d9\u05e8\u05d5\u05e9\u05d4 (Inheritance): In C++, inheritance is a mechanism of creating new classes that are derived from existing classes. The new class can inherit the properties and methods of the base class.\n\n3. \u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd (Polymorphism): C++ supports polymorphism, which means that a single name can be used to represent different types of objects. Polymorphism is achieved through method overloading and virtual functions.\n\n4. \u05e0\u05d5\u05e9\u05d0\u05d9\u05dd \u05e7\u05e9\u05d5\u05e8\u05d9\u05dd: The presentation also covers related topics such as abstract classes, templates, operator overloading, and exception handling. These concepts are important for writing robust and efficient C++ programs."},
{"slide_number": 2, "content": "Inheritance is the transfer of an individual's property and assets to their heirs after they pass away. In many cultures and legal systems, it is a structured process that involves laws and regulations determining who inherits what assets. Here are a few bullet points that summarize some of the key aspects of inheritance:\n\n- In most cases, inheritance is passed on to the spouse, children, or close family members of the deceased individual.\n- The inheritance process can be complex and involve legal documentation such as wills and trusts.\n- Inheritance may be subject to taxes, depending on the country and jurisdiction in which it occurs.\n- Disputes over inheritance can arise among family members, especially if there is no clear documentation or communication about the wishes of the deceased individual.\n- In some cases, individuals may choose to donate their inheritance to charity or other causes they care about.\n\nOverall, inheritance is an important process for passing on wealth and property from one generation to the next, and it is important to understand the legal and cultural customs surrounding it."},
{"slide_number": 3, "content": "This passage discusses inheritance in object-oriented programming. Inheritance allows us to reuse code by defining data members and member functions in a base class and having all the derived classes automatically inherit them. For example, if we have a base class for a two-wheeled vehicle, we can define data members for both wheels, the vehicle's direction, and its speed, as well as member functions to handle them. We can also add appropriate constructors for initializing the maximum speed, tire pressure, etc. for different types of two-wheeled vehicles such as bicycles and motorcycles. \n\nThe derived classes can then add unique members to represent features like engines or handlebars and utilize them when we use the derived classes. However, we can still access the public functions for handling the vehicle's tires, as they are inherited from the base class. This way, we can reduce duplication of code and make the implementation more efficient and organized."},
{"slide_number": 4, "content": "1. \u05d9\u05e8\u05d5\u05e9\u05d4 (inheritance): This refers to the process of creating a new class (called the \"derived\" class) from an existing class (called the \"base\" class). The derived class has all the properties and behaviors of the base class, as well as any additional ones that are defined specifically for the derived class.\n\n2. \u05d3\u05d5\u05d2\u05de\u05d4 (example): The code provided presents an example of inheritance. There are three classes defined in the code: TwoWheeledVehicle, Motorcycle, and Bicycle. Motorcycle and Bicycle are derived classes of TwoWheeledVehicle. This means that they both inherit the properties and behaviors of TwoWheeledVehicle.\n\n3. The TwoWheeledVehicle class: This is the base class. It has a public member function called \"getSpeed\" that returns an integer representing the speed of the vehicle. \n\n4. The Motorcycle and Bicycle classes: These are the derived classes of TwoWheeledVehicle. They do not have any additional properties or behaviors defined for them, so they simply inherit the getSpeed() function from the base class. \n\n5. The auto m = Motorcycle(); auto b = Bicycle(); statements: These create instances of the Motorcycle and Bicycle classes, respectively. \n\n6. The std::cout << m.getSpeed() << ' ' << b.getSpeed() << '\\n'; statement: This outputs the speed of the Motorcycle and Bicycle instances to the console using the getSpeed() function, separated by a space and followed by a newline character."},
{"slide_number": 5, "content": "This text describes how inheritance works in object-oriented programming. Inheritance allows one class to extend the functionalities of another class, the base class. Objects that are created from a subclass inherit the data and methods of the superclass, while also having their own unique properties and methods. When a reference or pointer is created to a subclass object, it points to the beginning of the object's layout, which includes the base class information followed by the subclass's additions. It is also possible to attach an object of a subclass to a reference of the base class, but you can only access members that are defined in the base class through these references or pointers."},
{"slide_number": 6, "content": "- \u05d9\u05e8\u05d5\u05e9\u05d4 (Inheritance): This is a programming concept where a class can inherit the properties and methods of another class. In the given code, the class \"Bicycle\" is inheriting from the class \"TwoWheeledVehicle\". \n\n- \u05d4\u05de\u05e9\u05da (Extension): Inheritance allows a subclass (a class that is inheriting from another class) to extend or add more functionality to the properties and methods inherited from the parent class. In the given code, the class \"Bicycle\" is extending the \"TwoWheeledVehicle\" class by adding its own method called \"ring()\".\n\n- \u05d3\u05d5\u05d2\u05de\u05d4 (Example): This is an example of how inheritance and extension work in a programming language such as C++. The code defines two classes, \"TwoWheeledVehicle\" and \"Bicycle\". The latter inherits from the former and adds its own method. The main function creates an object \"bike\" of the \"Bicycle\" class and calls its methods. It also calls a function \"f()\" that takes an object of the \"TwoWheeledVehicle\" class as a parameter."},
{"slide_number": 7, "content": "The presentation covers the topics of static and dynamic typing, as well as the behavior of the compiler during compilation. The compiler checks at compile time whether the member referred to in the code actually exists, but it only knows the type of the pointer or reference and not its actual address. Therefore, it only checks access to members of the base class, which is known at compile time as the static type and not the dynamic type, which is only known at runtime. Additionally, if a function is defined in both the base class and the derived class, the function called through a pointer or reference to the base class will always be the one in the base class, regardless of the actual type of the object. However, there are exceptions to this rule that will be explained later."},
{"slide_number": 8, "content": "The presentation includes two topics: Static typing and Dynamic typing. \n\nStatic typing means that the type of a variable is determined at compile-time and cannot change during the program's execution. Dynamic typing, on the other hand, means that the type of a variable is determined at runtime and can change during the program's execution.\n\nTo illustrate this concept, the presentation provides an example of two classes: TwoWheeledVehicle and Bicycle. Bicycle is a subclass of TwoWheeledVehicle. Both classes have a print() method that implements different functionality. The print() method in TwoWheeledVehicle prints the speed of the vehicle, while the print() method in Bicycle prints the speed and describes the vehicle as a bicycle.\n\nThe example shows static typing in action because the type of both classes and their methods are known at compile-time. However, it also shows dynamic typing because the method that gets executed when the print() method is called depends on the actual type of the object at runtime. In this case, the TwoWheeledVehicle object calls the print() method of the same name in the TwoWheeledVehicle class, while the Bicycle object calls the print() method in its own class."},
{"slide_number": 9, "content": "1. \"\u05d8\u05d9\u05e4\u05d5\u05e1 \u05e1\u05d8\u05d8\u05d9 \u05d5\u05d8\u05d9\u05e4\u05d5\u05e1 \u05d3\u05d9\u05e0\u05de\u05d9\" refers to two different ways of defining data types in programming. Static typing involves declaring a variable with a specific data type (such as int, string, or boolean) and then restricting that variable to only hold values of that type. Dynamic typing, on the other hand, allows a variable to hold values of any type at runtime. \n\n2. The code example provided demonstrates the concept of dynamic typing. The function \"void f(const TwoWheeledVehicle &v)\" takes a reference to an object of the \"TwoWheeledVehicle\" class as an argument, and then calls the \"print()\" method of that object. This allows us to pass in any subclass of \"TwoWheeledVehicle\" (such as a \"Bicycle\" object) and still call the correct \"print()\" method. \n\n3. The second part of the code example creates a \"Bicycle\" object and calls its \"print()\" method, which prints out \"Bicycle at 10 km/h\" (assuming that is the current speed of the Bicycle object). \n\n4. Finally, the function \"f(bike)\" is called with the \"bike\" object as the argument. Since \"bike\" is a subclass of \"TwoWheeledVehicle\", the function can still be called successfully. However, since the function is defined with a reference to a \"TwoWheeledVehicle\" object, the \"print()\" method of the \"TwoWheeledVehicle\" class is called instead of the \"Bicycle\" class. This results in the output \"TwoWheeledVehicle at 10 km/h\"."},
{"slide_number": 10, "content": "Polymorphism is a fundamental concept in object-oriented programming (OOP), referring to the ability of objects of different classes to be treated as if they are objects of a common superclass. The term \"polymorphism\" comes from the Greek words \"poly\" meaning \"many\" and \"morph\" meaning \"form.\" \n\nThere are two main types of polymorphism: \n\n1. **Compile-time polymorphism / Method overloading:** Compile-time polymorphism is the ability to use a single name to represent multiple methods, which differ in the number or the type of parameters they accept. The compiler determines which method to call based on the arguments passed to it. \n\n2. **Runtime polymorphism / Method overriding:** Runtime polymorphism is the ability of a subclass to provide its implementation for a method that is already defined in its superclass. The method in the subclass must have the same name, same parameters, and the same return type as the method in the superclass. The JVM determines which method to call at runtime based on the type of object that is calling the method. \n\nThe concept of polymorphism is essential for creating reusable and maintainable code. By leveraging polymorphism, we can write code that is more flexible and less prone to errors, making our programs easier to maintain and extend over time."},
{"slide_number": 11, "content": "Polymorphism refers to the ability of a function or method to have different behaviors based on the type of object it is being called on. In inheritance, the drive() method can be defined differently in each subclass, but can still be called through a pointer or reference to the base class to receive the appropriate behavior according to the specific object type, known as polymorphism or dynamic typing. To achieve this behavior, the drive() method is declared as virtual within the base class and the method is overridden in each subclass. If we want to use the implementation from the base class, we don't need to write anything. This behavior is enabled by virtual tables (vtbl) and virtual pointers (vptr)."},
{"slide_number": 12, "content": "The presentation covers the topic of polymorphism in programming, which refers to the ability of objects to take on multiple forms. In the example given, there is a class called \"TwoWheeledVehicle\" with a virtual function called \"drive\". The virtual keyword indicates that this function can be overridden by derived classes. \n\nThe \"Bicycle\" class is a derived class that overrides the \"drive\" function to print out the message \"Driving a bicycle\". This means that if an object of type \"Bicycle\" calls the \"drive\" function, it will print out this message instead of the message from the base class. \n\nOn the other hand, the \"Bicycle2\" class derives from \"TwoWheeledVehicle\" but does not override the \"drive\" function. This means that if an object of type \"Bicycle2\" calls the \"drive\" function, it will use the function from the base class and print out the message \"Driving a TwoWheeledVehicle\". \n\nOverall, this example demonstrates the usage of virtual functions to achieve polymorphism in C++."},
{"slide_number": 13, "content": "Polymorphism: Polymorphism is the ability of an object to take on multiple forms. It is a fundamental concept in object-oriented programming (OOP) and allows objects of different classes to be treated as if they are objects of the same parent class.\n\nExample: The code snippet provides an example of polymorphism in which the function f takes a reference to an object of class TwoWheeledVehicle and invokes its drive method. The function is then called with an object of class Bicycle, which is a subclass of TwoWheeledVehicle. The output of the function is \"Driving a bicycle\" which demonstrates that the object of the subclass is treated as if it were an object of the parent class.\n\nVoid and const: Void is a keyword used in C++ programming language to indicate that a function does not return any value. Const is a keyword used to specify that the value of a variable cannot be modified.\n\nThe code snippet also includes the use of void and const in the declaration of function f. The function has a return type of void, indicating that it does not return any value. The parameter v is defined as const, which means that the value of the parameter cannot be modified within the function.\n\nOutput: The code snippet also shows the difference in output when the drive method is called on objects of class Bicycle and Bicycle2. When bike.drive() is called, the output is \"Driving a bicycle\" because the drive method of the Bicycle class is invoked. However, when bike2.drive() is called, the output is \"Driving a TwoWheeledVehicle\" because the drive method of the parent class (TwoWheeledVehicle) is invoked."},
{"slide_number": 14, "content": "- Pure virtual: A function that is declared in a base class but is not implemented or defined there. Instead, subclasses are supposed to provide an implementation. It is marked by appending \"=0\" to the function declaration. Classes containing pure virtual functions are called abstract classes.\n- Abstract class: A class that contains one or more pure virtual functions. It cannot be instantiated directly because it is incomplete and lacks a complete implementation for one or more functions. Concrete classes (classes that are not abstract) must implement all the pure virtual functions of their abstract base classes. It is not necessary to re-declare a pure virtual function in an intermediate class if the implementation is only done in a subclass; the existence of the pure virtual function is inherited from the parent class."},
{"slide_number": 15, "content": "1. Pure virtual - A pure virtual function is a function declared within an abstract class that has no implementation within the class. It is represented by \"= 0\" at the end of the function declaration. This function must be implemented by any concrete (non-abstract) class that inherits from the abstract class.\n\n2. Example class TwoWheeledVehicle - This is an abstract class that has a pure virtual function named \"drive()\". The purpose of the class is to serve as a base class for any type of two-wheeled vehicle that needs to be implemented in the program.\n\n3. Class BicycleBase - This class inherits from the abstract class TwoWheeledVehicle but does not implement the \"drive()\" function. It is considered a base class that can be further inherited by other classes.\n\n4. Class Bicycle - This class inherits from the BicycleBase class and implements the \"drive()\" function. The function's implementation outputs the string \"Driving a bicycle\" to the console. This class is considered a concrete class, with a complete implementation that can be used in the program."},
{"slide_number": 16, "content": "- Pure virtual: This refers to a virtual function in a base class that has no implementation and must be overridden by a derived class in order to be used. It is denoted by using the \"= 0\" keyword at the end of the function declaration.\n\n- Example: This section provides an example of how the previously discussed concepts can be implemented in practice. It presents three classes - ElectricBike, BestElectricBike, and MountainBike - that inherit from a base class called BicycleBase.\n\n- ElectricBike: This is a derived class that inherits from BicycleBase and overrides its drive() function with a specific implementation. The override keyword indicates that this function is intended to replace the one in the base class.\n\n- BestElectricBike: This is another derived class that inherits from ElectricBike. It does not declare or define its own drive() function, but rather inherits it from ElectricBike.\n\n- MountainBike: This is a derived class that also inherits from BicycleBase. However, it does not override the pure virtual drive() function, so it remains an abstract class that cannot be instantiated directly. It must be further specialized by a derived class that provides an implementation for the drive() function."},
{"slide_number": 17, "content": "- Pure virtual: This refers to a virtual function that has no implementation in the base class, but it is expected to be overridden in derived classes. This makes the base class an abstract class, and it cannot be instantiated on its own.\n- Example: This is a generic term used in the code to refer to a placeholder or representative object.\n- \u05d4\u05de\u05e9\u05da (2): This likely means \"Continued (2)\" in Hebrew, but without context it is unclear what it refers to in this code snippet.\n- void f(const TwoWheeledVehicle& v) {...}: This is a function that takes an object of type TwoWheeledVehicle by reference and calls its drive() function. The function is defined with a void return type, indicating that it does not return any value.\n- auto bike = Bicycle(); bike.drive(); ...: This creates an object of type Bicycle using the default constructor, and then calls its drive() function, which prints \"Driving a bicycle\".\n- f(bike); ...: This passes the Bicycle object created earlier as an argument to the function f(). Since the argument is passed by reference, the drive() function is called on the original object, and the output is \"Driving a bicycle\".\n- auto bike2 = BestElectricBike(); bike2.drive(); ...: This creates an object of type BestElectricBike, which inherits from ElectricBike, and then calls its drive() function, which prints \"Driving an ElectricBike\".\n- auto bike3 = MountainBike(); ...: This attempts to create an object of type MountainBike, which is an abstract class and cannot be instantiated on its own. Therefore, this statement will not compile.\n- void f(BicycleBase b); ...: This is a function that takes an object of type BicycleBase by value. Since BicycleBase is an abstract class, it cannot be instantiated, and therefore this function cannot be called with a concrete object of its parameter type."},
{"slide_number": 18, "content": "Topic 1: \"\u05d3\u05d2\u05e9\u05d9\u05dd \u05dc\u05d9\u05e8\u05d5\u05e9\u05d4\" translates to \"Emphasis on inheritance\" and likely refers to object-oriented programming principles. Inheritance is a way of creating new classes that are built upon existing classes, allowing for code reuse and more efficient development. Emphasizing inheritance means that it is important to carefully consider what attributes and methods should be inherited by subclasses and how they should be organized in a logical and coherent way.\n\nTopic 2: \"\u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd \u05de\u05ea\u05d9 \u05e0\u05e4\u05e8\u05d9\u05d3 \u05dc\u05de\u05d7\u05dc\u05e7\u05d5\u05ea?\" translates to \"Polymorphism - when to separate into classes?\" Polymorphism is another key concept in object-oriented programming that allows objects of different classes to be treated as if they were the same type of object. This means that different objects can respond to the same methods in unique ways, even if they are completely different classes. Deciding when to separate into classes likely refers to how to organize different types of objects with unique behaviors in a logical and efficient way that still allows for polymorphism to be used effectively."},
{"slide_number": 19, "content": "The topic discusses whether it is necessary to separate different classes (and implement different virtual functions) or whether it is enough to keep a data member that contains relevant information that differs between different types of objects. To decide whether to separate into different classes, we should consider whether there is a difference in behavior (e.g. movement between a smart enemy and a regular enemy), which would require different implementations of virtual functions. In this case, it is better to separate into different classes so that the relevant implementations of the virtual function will be activated according to the relevant object. If the difference is only in a certain characteristic (such as the speed of movement of the character), there is no need to separate into different classes, and the difference can be preserved through a data member. It is easy to see why the latter option may be less successful and less maintenance-friendly, and it is better to separate into different classes if there is a significant difference in behavior. Deciding when to separate into different classes depends on the nature of the problem at hand and the specific differences that need to be accommodated."},
{"slide_number": 20, "content": "The topic being discussed is when to separate classes into different departments. The presented code example illustrates separating classes for SmartEnemy and RandomEnemy into different departments, specifically EnemyBase, instead of keeping them together in one class, Enemy.\n\nThe Enemy class has a private member variable named m_isSmart, which determines if the enemy is smart or not. In the move() function of the Enemy class, an if-else statement is used to determine whether to compute BFS or make a random move.\n\nThis approach is considered bad because it violates the principle of encapsulation. The m_isSmart variable is private but still affects the behavior of the public move() function.\n\nTo address this issue, the code suggests using inheritance to separate the SmartEnemy and RandomEnemy into their respective classes and create a common interface, EnemyBase, for accessing their move() function. In this way, the move() function is implemented appropriately in each subclass, and the private variables are kept encapsulated."},
{"slide_number": 21, "content": "The presentation seems to cover three topics:\n\n1. \"\u05de\u05ea\u05d9 \u05e0\u05e4\u05e8\u05d9\u05d3 \u05dc\u05de\u05d7\u05dc\u05e7\u05d5\u05ea?\" which translates to \"When do we separate into classes?\" This could be discussing the practice of organizing code into different classes based on their properties and behavior.\n\n2. The presentation gives an example code block of two classes called \"Bad! class FastEnemy\" and \"SlowEnemy.\" These classes have a \"move\" function that moves their location. The presentation may be explaining why this is an inefficient or poorly organized way to write this code.\n\n3. The presentation provides an alternative code called \"GOOD! class Enemy\" which includes a private integer variable called \"m_speed\" that is initialized in the constructor to either 50 or 20. The \"move\" function then uses this speed variable to move the location. The presentation may be demonstrating how this is a more organized and efficient way of writing the code."},
{"slide_number": 22, "content": "\u05d3\u05d2\u05e9\u05d9\u05dd \u05dc\u05d9\u05e8\u05d5\u05e9\u05d4 - \u05d4\u05d3\u05d2\u05e9\u05d9\u05dd \u05dc\u05d9\u05e8\u05d5\u05e9\u05d4 \u05d4\u05dd \u05d6\u05db\u05d5\u05d9\u05d5\u05ea \u05e2\u05dc \u05d4\u05e0\u05db\u05e1\u05d9\u05dd \u05e9\u05dc \u05de\u05ea\u05e0\u05d3\u05d1, \u05d5\u05de\u05d1\u05d8\u05d9\u05d7\u05d9\u05dd \u05e9\u05d4\u05e2\u05d5\u05e9\u05d9\u05dd \u05d0\u05ea \u05d4\u05e6\u05e2\u05d3\u05d9\u05dd \u05d4\u05e0\u05db\u05d5\u05e0\u05d9\u05dd \u05d9\u05e0\u05d4\u05dc\u05d5 \u05d0\u05ea \u05d4\u05e0\u05db\u05e1\u05d9\u05dd \u05db\u05e4\u05d9 \u05e9\u05d4\u05ea\u05d5\u05e8\u05de\u05d9\u05dd \u05e8\u05e6\u05d5.\n\n\u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd - \u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd \u05d4\u05d5\u05d0 \u05ea\u05db\u05d5\u05e0\u05d4 \u05e9\u05dc \u05d0\u05d5\u05d1\u05d9\u05d9\u05e7\u05d8\u05d9\u05dd \u05d1\u05de\u05d7\u05e9\u05d1, \u05e9\u05d1\u05d4\u05dd \u05d4\u05dd \u05d9\u05db\u05d5\u05dc\u05d9\u05dd \u05dc\u05d4\u05ea\u05e0\u05d4\u05d2 \u05d1\u05d0\u05d5\u05e4\u05df \u05e9\u05d5\u05e0\u05d4 \u05d1\u05d4\u05ea\u05d0\u05dd \u05dc\u05e1\u05d5\u05d2 \u05d4\u05e0\u05ea\u05d5\u05e0\u05d9\u05dd \u05e9\u05d4\u05dd \u05de\u05e4\u05e2\u05d9\u05dc\u05d9\u05dd \u05e2\u05dc\u05d9\u05d4\u05dd.\n\n\u05de\u05ea\u05d9 \u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd \u05e2\u05d5\u05d1\u05d3 - \u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd \u05e2\u05d5\u05d1\u05d3 \u05db\u05d0\u05e9\u05e8 \u05d9\u05e9 \u05dc\u05de\u05d7\u05e9\u05d1 \u05db\u05de\u05d4 \u05d3\u05e4\u05e0\u05d5\u05ea \u05e9\u05d5\u05e0\u05d5\u05ea \u05dc\u05d4\u05ea\u05e0\u05d4\u05d2\u05d5\u05ea \u05e9\u05dc \u05d0\u05d5\u05ea\u05d5 \u05d0\u05d5\u05d1\u05d9\u05d9\u05e7\u05d8. \u05dc\u05de\u05e9\u05dc, \u05d0\u05dd \u05e0\u05de\u05de\u05e9 \u05de\u05d7\u05dc\u05e7\u05d4 \"\u05de\u05e7\u05dc\u05d8\" \u05d5\u05de\u05d7\u05dc\u05e7\u05d4 \"\u05d1\u05d9\u05ea\", \u05d0\u05e4\u05e9\u05e8 \u05dc\u05d4\u05e4\u05e2\u05d9\u05dc \u05e4\u05d5\u05e0\u05e7\u05e6\u05d9\u05d4 \"\u05dc\u05d9\u05e9\u05d5\u05df\" \u05d5\u05d4\u05d0\u05d5\u05d1\u05d9\u05d9\u05e7\u05d8 \u05e9\u05dc \"\u05de\u05e7\u05dc\u05d8\" \u05d9\u05d7\u05d6\u05d9\u05e8 \"\u05de\u05e8\u05e4\u05e1\u05ea \u05dc\u05d9\u05e9\u05d5\u05df\", \u05d0\u05d1\u05dc \u05d0\u05d5\u05ea\u05d5 \u05e7\u05d5\u05d3 \u05e2\u05d1\u05d5\u05e8 \u05e4\u05e2\u05d5\u05dc\u05d4 \u05d6\u05d5 \u05e2\u05dc \u05d0\u05d5\u05d1\u05d9\u05d9\u05e7\u05d8 \u05e9\u05dc \"\u05d1\u05d9\u05ea\" \u05d9\u05e7\u05d1\u05dc \"\u05d7\u05d3\u05e8"},
{"slide_number": 23, "content": "The topics being explained in this text relate to polymorphism and object-oriented programming. The first point discusses the need for polymorphic behavior and the use of objects with types inherited from base classes through pointers or references. If the object's type is known, there is no need for polymorphism, and it can be used directly. Using polymorphism through pointers or references allows directing towards an object with the type of one of the inheritance classes, enabling polymorphic behavior. The text then highlights the lowest override of a virtual function as the determining factor of how polymorphic behavior works.\n\nThe final point warns against receiving a parameter of base class type by-value instead of through pointers or references. When received by-value, the original object is copied, causing slicing and losing its other class-specific traits. A general guideline is suggested to prevent similar errors, and finally, the text reiterates the need for polymorphic behavior to operate correctly."},
{"slide_number": 24, "content": "\u05d2\u05e9\u05d9\u05dd \u05dc\u05d9\u05e8\u05d5\u05e9\u05d4 (Emphasis on inheritance) - When writing object-oriented programs, it is common to create classes that inherit properties and methods from other classes. To avoid confusion and unintended behavior, it is important to clearly define and document the inheritance hierarchy and the scope of each class.\n\n\u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd (Polymorphism) - This is the ability of objects of different classes to be treated as if they are of the same class, even though they may have different properties or methods. This allows for more flexible and reusable code.\n\n\u05e9\u05d9\u05de\u05d5\u05e9 \u05d1\u05de\u05d9\u05dc\u05d4 override (Use of the word override) - In object-oriented programming, the term \"override\" is used when a subclass provides its own implementation of a method that is already defined in the superclass. This allows for customization of the behavior of inherited code without modifying the original class."},
{"slide_number": 25, "content": "This text explains the concept of the \"override\" keyword in C++. When defining a function in a derived class that overrides a virtual function in the base class, it is recommended to use the keyword \"override\" at the end of the function declaration. Although the code will still compile and behave polymorphically without the keyword, it is important to note that the compiler won't be able to detect if the overridden function was changed and is no longer an override. \n\nPrior to C++11, \"override\" was the only mechanism for overriding virtual functions, but it had the disadvantage of not detecting errors if the function wasn't truly an override. Therefore, since C++11, it is advisable to use the keyword \"override\" whenever a function is intended to be an override. This will cause the compiler to create a compilation error if the function is not actually overriding a virtual function in the base class."},
{"slide_number": 26, "content": "The term \"virtual d-tor\" refers to a virtual doctor, which is a healthcare professional who provides medical care through telemedicine technology. Here are some key points to understand about virtual d-tors:\n\n- Telemedicine technology enables virtual d-tors to communicate with patients remotely, using audio and video calls, instant messaging, or secure online portals.\n- Virtual d-tors can diagnose and treat many common medical conditions, such as cold and flu symptoms, skin rashes, allergies, and minor injuries.\n- The convenience and accessibility of virtual d-tors can improve healthcare access and outcomes for patients who live in rural or remote areas, who have mobility or transportation barriers, or who need to monitor chronic conditions.\n- Virtual d-tors must follow the same medical standards and guidelines as in-person doctors, and their services are typically covered by health insurance plans.\n- However, virtual d-tors may not be able to provide all types of care, such as physical exams, diagnostic tests, or emergency treatments, and may need to refer patients to a traditional doctor or hospital for further evaluation.\n\nOverall, virtual d-tors are a promising innovation for expanding healthcare access and improving patient outcomes, especially in the context of the COVID-19 pandemic and social distancing measures."},
{"slide_number": 27, "content": "This presentation discusses the importance of defining virtual functions and d-tors in base classes. It is recommended to define the d-tor as virtual, even if the implementation is empty. The reason for this is that when objects of derived classes are deleted through a base class pointer, it is important that the correct d-tor is called. If all d-tors are empty, it is still important to make them virtual so that the correct one is invoked. This is especially important for polymorphism. If a base class with virtual functions is defined, then any derived classes must also have virtual d-tors to ensure that the correct functions are called."},
{"slide_number": 28, "content": "ABC, or Abstract Base Class, is a concept in object-oriented programming where a class is created with some methods left undefined. This class cannot be instantiated, but it can serve as a base for other classes that inherit from it. \n\nThe idea behind an ABC is to create a template for other classes to follow. By defining only the methods that are necessary for the base class to function, it allows for greater flexibility in creating subclasses. This is because the methods that have not been defined can be implemented differently by the subclasses that inherit from the ABC.\n\nFor example, imagine an ABC called \"Animal\" with methods like \"eat\" and \"move\" left undefined. Subclasses like \"Lion\", \"Giraffe\", and \"Elephant\" can inherit from \"Animal\" and implement those methods in their own unique ways (i.e. Lions might eat meat, while Giraffes eat leaves).\n\nOverall, ABCs allow for greater code reuse and flexibility in object-oriented programming."},
{"slide_number": 29, "content": "This presentation discusses the importance of avoiding inheriting from concrete classes, which are classes that are not abstract. The example given is of a base class called \"Base\" and a derived class called \"Derived\", where the derived class inherits from the concrete base class. This is deemed as bad practice. \n\nInstead, it is recommended that all base classes, including intermediate ones, should be abstract, particularly if they have virtual functions. A new example is given using an abstract base class called \"Base2\" and a derived class called \"Derived2\", which correctly inherits from the abstract base class. \n\nThe presentation concludes with the concept of ABC, which stands for Abstract Base Class. This means that only the leaves of the inheritance tree should be concrete classes."},
{"slide_number": 30, "content": "These topics are related to programming concepts in C++ language. The first topic discusses one reason for using the \"by-value\" parameter passing method instead of using a pointer or reference. This is to prevent accidentally receiving a parameter of a derived class as a base class, which can cause slicing (losing information about the derived class). Passing by value creates a copy and prevents creating an object of an abstract class.\n\nThe second topic explains another deeper reason for using abstract base classes (ABCs) in C++. There is no good way to define the assignment operator for a non-abstract base class. This problem can be solved by defining ABCs for the base classes and using virtual functions to override them. The book \"More Effective C++\" by Scott Meyers explains this concept in greater detail."},
{"slide_number": 31, "content": "The presentation covers two topics:\n\n1. Hiding: In computer programming, hiding refers to the practice of encapsulating an object's behavior and data so that they are not accessible to other code in the program. This is typically achieved through the use of access modifiers, such as private or protected, which restrict access to certain parts of an object. Hiding can help to prevent unintended changes to an object's state, improve code maintainability, and reduce the risk of bugs.\n\n2. \u05d4\u05ea\u05e0\u05d4\u05d2\u05d5\u05ea \u05e2\u05dd overload set (Behavior with overload set): Overloading is a feature in many programming languages that allows a function to have multiple implementations with different parameter types or numbers. The presentation likely discusses how to appropriately design and handle an overload set, which can improve code readability and flexibility but also introduces potential confusion and maintenance challenges. This may involve using clear and consistent naming conventions, avoiding ambiguous method signatures, and properly documenting the different overload options."},
{"slide_number": 32, "content": "- Hiding: Sometimes it is useful to define a function in a base class and add overloading for it in a derived class. This is referred to as overloading and not overriding of a virtual function.\n- Overloading set: Refers to a virtual function having multiple overloads.\n- Class Derived: Inherits from class MyBase and overrides function 'f' by creating a new overload.\n- What happens in the code snippet: An object of type Derived is created and its function 'f' is called with two arguments: itself and the integer 42. The second call results in a compilation error because the integer argument is not of type MyBase&."},
{"slide_number": 33, "content": "1. Hiding: In object-oriented programming, hiding refers to the ability of a subclass to hide a method or attribute inherited from its superclass. This means that the implementation of the method or attribute in the subclass will be used instead of the implementation in the superclass when the method or attribute is called.\n\n2. Inheritance and overload set: Overload set refers to a group of functions that have the same name but different parameters. When a subclass inherits a function from its superclass that has the same name as one in the subclass, the overload set will contain both functions. The function defined in the subclass will \"hide\" the function in the superclass. This means that when the function is called using the name, only the function in the subclass will be called, not the one in the superclass. \n\nThe example given is similar to a scenario in which the same variable name is defined in different scopes. When the variable is called using the name, the compiler will find it in the closest scope."},
{"slide_number": 34, "content": "1. Hiding - This refers to a situation in which a name in a derived class hides the same name in the base class. When a member function in a derived class has the same name as a member function in the base class, the derived class's member function hides the base class's version of the function.\n\n2. Overloading set - This refers to a situation in which multiple functions with the same name are defined within the same scope, but with different parameters. When the compiler searches for a function with a particular name, it creates an overload set containing all the functions with that name. The compiler then decides which function to use based on the arguments passed to the function.\n\n3. Scope - This refers to the area of code within which a name is visible. When a compiler searches for a function with a particular name, it searches within the current scope of the class first. If the function is not found within the current class, the compiler will search in the base class.\n\n4. Overloading in inherited classes - When a function is overloaded in an inherited class, the functions in the base class are not considered part of the overload set. The derived class's functions take precedence over the base class's functions."},
{"slide_number": 35, "content": "1. Hiding - This refers to a situation where a member function or variable in a derived class has the same name as a member function or variable in the base class; this causes the base class member to be hidden and cannot be accessed through a variable of the derived class.\n\n2. \u05d9\u05e8\u05d5\u05e9\u05d4 \u05d5-overload set- This refers to inheritance and an overload set, which is a group of functions with the same name but different parameters.\n\n3. \u05e4\u05ea\u05e8\u05d5\u05df \u05d5\u05de\u05d4 \u05d0\u05dd \u05e0\u05e6\u05d8\u05e8\u05da \u05e9\u05d7\u05dc\u05e7 \u05de\u05d4- overload set \u05d9\u05d4\u05d9\u05d4 \u05d1\u05de\u05d7\u05dc\u05e7\u05ea \u05d4\u05d1\u05e1\u05d9\u05e1 \u05d5\u05d7\u05dc\u05e7 \u05d1\u05de\u05d7\u05dc\u05e7\u05d4 \u05d4\u05d9\u05d5\u05e8\u05e9\u05ea? - This refers to a situation where part of the overload set is in the base class and part is in the derived class.\n\n4. \u05de\u05e7\u05d5\u05dd \u05db\u05d6\u05d4 \u05d4\u05d5\u05d0 double dispatch - This is a solution to the problem described in topic 3, where the function that is overloaded in both classes is implemented through a double dispatch mechanism.\n\n5. \u05d4\u05e8\u05d1\u05d4 \u05de\u05d4\u05e4\u05d5\u05e0\u05e7\u05e6\u05d9\u05d5\u05ea \u05db\u05d3\u05d0\u05d9 \u05dc\u05de\u05de\u05e9 \u05d1\u05de\u05d7\u05dc\u05e7\u05d5\u05ea \u05d4\u05d1\u05d9\u05e0\u05d9\u05d9\u05dd - This refers to implementing many functions in intermediate classes.\n\n6. \u05d0\u05ea \u05db\u05dc \u05d4\u05d4\u05ea\u05e0\u05d2\u05e9\u05d5\u05d9\u05d5\u05ea \u05e2\u05dd \u05d0\u05d5\u05d1\u05d9\u05d9\u05e7\u05d8 \u05e1\u05d8\u05d8\u05d9 \u05db\u05d3\u05d0\u05d9 \u05dc\u05de\u05de\u05e9 \u05d1\u05de\u05d7\u05dc\u05e7\u05ea \u05d4\u05d1\u05d9\u05e0\u05d9\u05d9\u05dd - This refers to implementing all collisions with a static object in the intermediate class.\n\n7. \u05db\u05d9 \u05e2\u05d1\u05d5\u05e8 \u05db\u05d5\u05dc\u05dd \u05d4\u05de\u05d9\u05de\u05d5\u05e9 \u05d9\u05d4\u05d9\u05d4 \u05e4\u05e9\u05d5\u05d8 \u05e8\u05d9\u05e7, \u05d4\u05e4\u05ea\u05e8\u05d5\u05df \u05d4\u05d5\u05d0 \"\u05dc\u05d9\u05d9\u05d1\u05d0\" \u05d0\u05ea \u05d4\u05e9\u05de\u05d5\u05ea \u05d4\u05e8\u05dc\u05d5\u05d5\u05e0\u05d8\u05d9\u05d9\u05dd \u05de-scope \u05d0\u05d7\u05d3 \u05dc\u05e9\u05e0\u05d9 - This refers to importing relevant names from one scope to another, making the implementation simple and empty.\n\n8. \u05db\u05e9\u05d4\u05e7\u05d5\u05de\u05e4\u05d9\u05d9\u05dc\u05e8 \u05d9\u05d7\u05e4\u05e9 \u05d0\u05ea \u05d4\u05e9\u05dd \u05e9\u05dc \u05d4\u05e4\u05d5\u05e0\u05e7\u05e6\u05d9\u05d4 \u05d1"},
{"slide_number": 36, "content": "RTTI stands for Run-Time Type Identification, which is a feature of programming languages that allows you to check at runtime what is the actual type of an object, even if it is declared as a pointer or a reference to a base class.\n\nThis feature is particularly useful in object-oriented programming, where it allows you to write more generic code that can handle objects of different types without knowing the exact type at compile-time. For example, you can write a function that takes a base class object as a parameter and then use RTTI to determine which derived class it belongs to and call the appropriate method.\n\nRTTI can be implemented in different ways, but it typically involves storing additional metadata about the objects at runtime, such as a virtual function table or a type information object. This metadata can then be queried using dynamic_cast or typeid operators.\n\nRTTI is a powerful tool that can make your code more flexible and adaptable, but it should also be used judiciously, as it can add runtime overhead and may be prone to errors if not properly tested."},
{"slide_number": 37, "content": "- RTTI: Runtime Type Identification. Sometimes there is a need to identify the dynamic type of a specific object during runtime. The language provides us with two tools for this purpose: typeid and dynamic_cast.\n- typeid: A tool for obtaining information about the type of an object during runtime. It returns a reference to a type_info object that contains type information.\n- dynamic_cast: A tool for converting a pointer/reference of a base class to a derived class during runtime. It checks if the conversion is valid and returns a null pointer/reference if it's not.\n- Warning: It's easy to fall into the temptation of using these tools instead of polymorphism. We should be careful and consider when these tools are truly necessary and when regular polymorphism suffices."},
{"slide_number": 38, "content": "The use of `typeid` is suitable for finding an exact type. On the other hand, `dynamic_cast` can give a positive response even when checking base classes of the object. The presented code demonstrates the use of `dynamic_cast` and `typeid` with the `class A`, `class B`, `class C`, and `class D`. Running the function `f()` will result in printing \"B*C*C\" and a memory leak. This is because `dynamic_cast` has matched `B*` and `C*` correctly, but `typeid` has not. This comparison of `dynamic_cast` vs. `typeid` is related to RTTI (Run-Time Type Information)."},
{"slide_number": 39, "content": "RTTI, or runtime type identification, is a feature in C++ that allows the program to identify the data type of an object during runtime. dynamic_cast and typeid are both operators used for RTTI. dynamic_cast is used to perform polymorphic type checking during runtime and is primarily used to check whether a pointer of a base class can be safely converted to a pointer of a derived class. On the other hand, typeid is used to get the type information of an object at both compile-time and runtime. It returns the static type of the variable instead of the dynamic type, which can sometimes lead to confusion. \n\nIf one of the types is not polymorphic, meaning it does not contain any virtual functions, dynamic_cast cannot be used and will result in a compilation error. In this case, typeid can be used as it works with non-polymorphic types and returns the static type of the object.\n\nWhile dynamic_cast can be used on both pointers and references, typeid is typically used with references. However, if polymorphic behavior is desired, typeid can be used with pointers as well. \n\nIf the conversion performed by dynamic_cast fails, it returns a null pointer, whereas typeid does not have a null reference equivalent. In this case, exceptions can be used to handle the error."},
{"slide_number": 40, "content": "\u05d9\u05e8\u05d5\u05e9\u05d4 (Inheritance):\n- Inheritance is a mechanism in object-oriented programming that allows one class to extend or inherit properties and behaviors from another class.\n- The class that inherits the properties is called the derived class or subclass, and the class from which it inherits is called the base class or superclass.\n- The benefits of inheritance are that it promotes code reuse, allows for better organization of code, and helps to create more specific and specialized classes.\n\nAccess Modifiers:\n- Access Modifiers are keywords used in object-oriented programming languages to set the accessibility of classes, methods, variables and constructors.\n- The four main access modifiers in most programming languages are public, private, protected and default.\n- Public members can be accessed from anywhere in the program, private members can only be accessed within the class itself, protected members can be accessed within the class and its subclasses, and default members can be accessed within the same package.\n- Access modifiers help to maintain the security and stability of code, prevent unwanted changes, and make code easier to understand and modify over time."},
{"slide_number": 41, "content": "The presentation covers inheritance and access modifiers in object-oriented programming. In class inheritance, a subclass or derived class (B) can inherit properties and methods from a superclass or base class (A) using the \"public\" keyword in the class definition. This means that anyone who can access the subclass can also access the inherited elements from the superclass.\n\nThe \"use\" of inheritance involves accessing members from the base class, and utilizing conversions from the derived class to the base class. For example, an object from the derived class can be assigned to a pointer of the base class type. However, if \"protected\" or \"private\" keywords are used instead of \"public\" in the inheritance definition, then it means that outside the class (or outside the inheriting classes), the members inherited from the base class cannot be accessed and objects cannot be treated as if they are of the base class type."},
{"slide_number": 42, "content": "In object-oriented programming, inheritance allows a subclass to inherit the methods and properties of its parent class. Access modifiers control the level of visibility and accessibility of these inherited elements. In most cases, inheritance should be defined as public, allowing for full access to the parent class's public and protected members. However, in some cases, when the inheritance is only needed for internal implementation purposes, inheritance can be defined as something other than public. If inheritance is defined as protected, the current class and its subclasses can access public and protected members of the base class, but not private members. It's important to note that if inheritance is defined as private, the subclass is not actually related to the base class in an 'is-a' relationship. Overall, the choice of access modifiers in inheritance is crucial for properly accessing and utilizing the elements of the parent class within the child class."},
{"slide_number": 43, "content": "Double Dispatch is a design pattern used in object-oriented programming languages such as Java and C++. It enables selecting a method to invoke based on the runtime types of two objects. \n\nThe pattern facilitates achieving the polymorphic behavior of objects. In simple words, it means choosing a method based on both the `runtime` type of the `receiver` and the type of the `argument`, as opposed to the traditional way of method selection based on only the receiver's `runtime` type. \n\nDouble Dispatch is achieved by overloading a method with multiple methods that differ in parameter types. The appropriate method to call is then selected based on the `runtime` types of both the object invoking the method and the input argument.\n\nIn essence, Double Dispatch allows for a more dynamic and selective way of executing a method based on multiple object types, making it a powerful tool in object-oriented programming."},
{"slide_number": 44, "content": "Double Dispatch is a programming concept where the handling of collisions between different objects is done in a different way depending on the type of object that is involved. For example, if a Pac-Man collides with a wall, a ghost, or a cookie, the way Pac-Man reacts is different in each case. The aim is to have a simple and generic way of handling these collisions, using polymorphism. Normally, objects are held using a pointer to their base class, but this is not sufficient for collision handling, as the handling depends on the specific type. Polymorphism, using virtual functions, is the solution to this problem. The collision handling function is defined as a virtual function, which can then be implemented uniquely in each class that inherits it, as needed."},
{"slide_number": 45, "content": "Double dispatch is a programming problem where a function is only virtual in relation to the object it is activated on, not in relation to its parameters, but its behavior should be polymorphic in relation to two objects, as both participate in the collision. The language does not naturally give us such ability. The parameter we pass will be received in the function according to its static type, the type known at compile time (in this case, according to the base class) and not according to its dynamic type, which will only be known at runtime."},
{"slide_number": 46, "content": "Double dispatch is a design pattern where the behavior of a method depends on both the type of the object and the type of one of its arguments. \n\nThe problem with implementing collisions in games is that different types of game objects may interact with each other in different ways, so a class like `GameObject` may need to have different collision behavior for different objects. \n\nThe provided example code shows a basic implementation of the double dispatch pattern for handling collisions in a game. The `GameObject` class defines a `collidesWith` method that takes another `GameObject` as an argument and returns a boolean indicating whether the two objects intersect. It also defines two virtual methods, `handleCollision` with a `GameObject` argument and `handleCollision` with a `Wall` argument, both of which have no implementation. \n\nThe `Monster` class, which is derived from `GameObject`, overrides both `handleCollision` methods to define its own collision behavior with other game objects and walls. With this pattern, when a collision occurs between a `Monster` and another game object or a wall, the appropriate `handleCollision` method will be called based on the specific types of the two objects."},
{"slide_number": 47, "content": "Double Dispatch is a design pattern used in object-oriented programming. It addresses the issue of how to call a specific method in a hierarchy of classes with multiple forms of inheritance. \n\nIn the example given, a vector called \"m_objects\" contains pointers to objects of type \"GameObjects\". If a specific type of object, like a \"Monster\", collides with another specific type of object, like a \"Wall\", the \"handleCollision\" method will be called. However, since there is no polymorphism of parameters in C++, the method that is called is determined at compile time based on the type of the argument passed to it, which in this case is \"GameObject\". \n\nTherefore, the specific implementation of \"handleCollision\" for the \"Monster\" class will be called in this scenario if \"m_objects[i]\" points to a \"Monster\" object and \"m_objects[j]\" points to a \"Wall\" object. The overloading that will be called is the one that takes a \"GameObject\" argument."},
{"slide_number": 48, "content": "Double dispatch is a solution in software development that involves using two virtual function calls to determine the exact types of two objects in a collision. This approach helps to avoid the creation of multiple if/else statements and is used to ensure that the correct handling functions are called. In the example given, the handleCollision function is called on one object, but the exact type of the other object in the collision is determined using two virtual function calls. By \"switching roles\" between the two objects and calling the function again with the parameter *this, which is of known type (Monster in this case), the appropriate handling function is called. This allows for more precise handling of the collision without needing to create many different if/else statements."},
]