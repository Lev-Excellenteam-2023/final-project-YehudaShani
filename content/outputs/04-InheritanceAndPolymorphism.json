[
{"slide_number": 0, "content": "The presentation, titled \"Inheritance and Polymorphism,\" was likely given at an academic institution in Israel in the year 2013 (\u05ea\u05e9\u05e4\"\u05d2). It covered the use of C++ programming language in developing software. One of the important concepts covered in the presentation was the idea of inheritance, which involves passing on properties and behaviors from one class or object to another. Polymorphism was also discussed, which involves the ability of a single object to take on different forms or behaviors. The presentation was likely given by a team called Excellenteam, who are likely experts in C++ programming, and may have been presenting to students or other software developers looking to learn more about these concepts."},
{"slide_number": 1, "content": "The presentation aims to review the concepts of inheritance and polymorphism in C++ programming language. \n\n1. Inheritance: It is a mechanism that allows a class to inherit properties and characteristics from another class. The primary class is called the base class, and the inheriting class is called the derived class. Inheritance provides code reusability, enhances extensibility, and simplifies code maintenance.\n\n2. Polymorphism: It is the ability of an object to take different forms and exhibit different behaviors by the same interface. Polymorphism allows code flexibility, improves code readability, and facilitates dynamic binding. \n\n3. Related topics: The presentation may also cover related concepts such as abstract classes, virtual functions, override and final keywords, dynamic cast, and static cast, among others. These topics enhance the understanding and practical application of inheritance and polymorphism in C++ programming."},
{"slide_number": 2, "content": "The topic of inheritance, or \u05d9\u05e8\u05d5\u05e9\u05d4 in Hebrew, refers to the transfer of property or assets from one generation to another. Here are some key points related to this topic:\n\n1. Passing down property: Inheritance is often associated with the transfer of property from a deceased person to their heirs. This can include real estate, financial investments, and personal possessions.\n\n2. Legal framework: Inheritance is typically governed by laws and regulations that vary by jurisdiction. In Israel, for example, the Succession Law determines how property is divided among heirs, depending on factors such as the presence of a will and the degree of kinship between the deceased and the heirs.\n\n3. Intestate succession: If someone dies without leaving a will, their property will be distributed according to the rules of intestate succession. In Israel, this means that the spouse and children of the deceased generally inherit the estate, with certain exceptions.\n\n4. Estate planning: To ensure that their assets are distributed according to their wishes, many people engage in estate planning. This can involve creating a will, establishing trusts, and making other arrangements to manage their property after they die.\n\n5. Complexities and disputes: Inheritance can be a complex and emotionally charged area, particularly when there are disputes over the distribution of assets. It's important for families to communicate openly and seek legal guidance to help ensure that the process is as smooth and fair as possible."},
{"slide_number": 3, "content": "Inheritance allows for reuse of code by writing it once in a base class and having all derived classes automatically inherit it. For example, if we have a base class for a two-wheeled vehicle, we can define the data members that represent the two wheels, the direction of the vehicle, and its speed, as well as member functions for handling them. We can then add appropriate constructors for initializing values such as maximum speed and tire pressure in derived classes such as bicycles and motorcycles. We can still access the public functions for handling tires, as they are inherited from the base class. This makes coding more efficient and organized."},
{"slide_number": 4, "content": "Topic 1: \u05d9\u05e8\u05d5\u05e9\u05d4 (Inheritance)\nInheritance is a fundamental concept in object-oriented programming that allows one class (child or derived class) to inherit the properties and methods of another class (parent or base class). The child class can add or override its own methods, variables, and properties in addition to those inherited from the parent class. Inheritance is a way to reuse code and make it more scalable and maintainable.\n\nTopic 2: \u05d3\u05d5\u05d2\u05de\u05d4 (Example)\nThis topic provides an example of inheritance using C++ programming language. It defines a base class called TwoWheeledVehicle that has a method named getSpeed(). It also defines two child classes called Motorcycle and Bicycle that inherit from the base class TwoWheeledVehicle. Both child classes do not have any additional methods or properties.\n\nThe code then creates instances of the Motorcycle and Bicycle classes using the auto keyword. Finally, it prints out the speed of both the motorcycle and bicycle objects by calling the getSpeed() method using cout. Since the child classes inherit the getSpeed() method from the parent class, both motorcycle and bicycle objects can call it without any issues."},
{"slide_number": 5, "content": "The topic discussed describes the ability to use inheritance in object-oriented programming. Inheritance allows for a subclass to inherit the properties and methods of its parent class. The presentation explains that a pointer can be used to refer to an object of the subclass, and that the object layout will include information from both the subclass and the parent class. Additionally, an object of the subclass can be attached to a reference to the parent class. However, it\u2019s important to note that references and pointers can only access members defined in the parent class."},
{"slide_number": 6, "content": "\u05d9\u05d9\u05e8\u05d5\u05e9\u05d4 (Inheritance) - This code includes two classes, TwoWheeledVehicle and Bicycle. Bicycle is derived from TwoWheeledVehicle using inheritance. This means that Bicycle has all the public members of the base class, as well as its own.\n\n\u05d4\u05de\u05e9\u05da (Extension) - Bicycle is an extension of TwoWheeledVehicle, meaning it adds additional members (in this case, the ring() function) to the ones it inherited from its base class.\n\n\u05d3\u05d5\u05d2\u05de\u05d4 (Example) - This code provides an example of inheritance and how it can be used. The function f() takes a reference to a TwoWheeledVehicle object, and the Bicycle object bike is passed to it. Since Bicycle is a derived class of TwoWheeledVehicle, it can be up-casted to the base class and passed to the function. However, when trying to call the ring() function via the base class object, compilation error occurs since it's not a member of the base class."},
{"slide_number": 7, "content": "The topics mentioned in this presentation are related to the characteristics of static and dynamic types in programming and how the compiler checks if a member exists during compilation. The compiler can only determine the type of the pointer/reference, but it does not know its actual memory address. Therefore, it can only check access to members of the base class at compile time, based on the static type that is declared in code. Static type is known at compilation time, while dynamic type is known only at runtime, which means that the compiler cannot access members of the derived class. Similarly, if a function is defined in both the base and derived classes, the one in the base class will be called regardless of the actual object type. However, this can change when discussing the dynamic type, which will be explained in more detail later."},
{"slide_number": 8, "content": "This presentation seems to be discussing static and dynamic typing in programming, using the example of a class called \"TwoWheeledVehicle\" and a subclass of that class called \"Bicycle.\" \n\nStatic typing refers to the practice of specifying the datatype of a variable at compile-time, whereas dynamic typing allows the datatype of a variable to be determined at runtime. \n\nIn the code example, the class \"TwoWheeledVehicle\" has a method called \"print\" that prints out the vehicle's speed. This method is defined as a const (meaning it doesn't modify any member variables of the class) and is declared with the static type of \"void.\"\n\nThe subclass \"Bicycle\" also has a method called \"print\" that overrides the method of the parent class. In this case, the method is also defined as a const and has the static type of \"void.\"\n\nOverall, this example demonstrates how both static and dynamic typing can be used in conjunction with inheritance and polymorphism in object-oriented programming."},
{"slide_number": 9, "content": "1. Static and Dynamic Types: Static type refers to the type of an object that is known at compile-time and cannot change during the program's execution, while the dynamic type is the type of an object that is determined at runtime and can change during the program's execution. For example, in C++, when you define a variable with a specific type, such as int x = 5, the static type of x is integer. However, the dynamic type can change if you assign a different value to x at runtime, such as x = \"hello\", which would change the dynamic type of x to string.\n\n2. Example: The code example provided shows a function called f that takes a constant reference to a TwoWheeledVehicle object and calls the print function on it. The TwoWheeledVehicle class is likely defined elsewhere in the program. Then, an instance of the Bicycle class is created and its print function is called, which prints \"Bicycle at 10 km/h\". Finally, the f function is called with the bike instance as the argument, but instead of printing \"Bicycle at 10 km/h\", it prints \"TwoWheeledVehicle at 10 km/h\". This is because the object's static type is Bicycle, but its dynamic type is TwoWheeledVehicle when passed to the f function.\n\n3. Continue void f: The code example is incomplete, and it is not clear what the intended continuation of the f function is."},
{"slide_number": 10, "content": "Polymorphism is a concept in object-oriented programming that allows objects of different classes to be treated as if they were objects of a common superclass. It is the ability of an object to take on many forms or have multiple behaviors. There are two types of polymorphism: runtime polymorphism and compile-time polymorphism.\n\n1. Runtime Polymorphism: It is also known as dynamic polymorphism. In this type of polymorphism, the method to be executed is decided at runtime based on the actual object type. For example, if we have a superclass called \"Animal\" and two subclasses called \"Dog\" and \"Cat,\" both of which inherit from \"Animal.\" If we call a method \"makeSound()\" on the object of \"Animal,\" then the specific implementation of that method will be decided at runtime based on the actual object type.\n\n2. Compile-time Polymorphism: It is also known as static polymorphism. In this type of polymorphism, method overloading is used. Method overloading allows different methods to have the same name, but different parameters. At compile-time, the correct method is chosen based on the number and type of arguments passed to it.\n\nPolymorphism is a key concept in object-oriented programming and allows for more flexible and modular code. By treating different objects as if they were the same type, programmers can write more generic and reusable code."},
{"slide_number": 11, "content": "The presentation explains the concept of polymorphism in object-oriented programming. Polymorphism means that a function can have multiple forms depending on the type of object that it is called on. In the case of inheritance, the function is defined differently in each of the child classes but can still be called using a pointer or reference to the base class.\n\nTo achieve this behavior, we declare the function as virtual within the base class and then use the override keyword in the child classes to indicate that they are implementing the function in their own unique way. It is not necessary to implement the function in the child class if we want it to behave the same way as it does in the base class.\n\nTo enable polymorphism, the compiler uses a virtual method table (vtbl) and virtual pointer (vptr) to determine which implementation of the function to use based on the type of object that it is called on. This allows for the same function to have different behaviors depending on the specific object it is called on, enabling greater flexibility in object-oriented programming."},
{"slide_number": 12, "content": "\u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd means \"polymorphism\" in Hebrew, and it refers to the ability of objects of different classes to be treated as if they are objects of the same class. This is usually achieved through inheritance and virtual functions.\n\nIn this code example, we have a base class called TwoWheeledVehicle, which has a virtual function called drive(). This function is marked as virtual, which allows derived classes to override it with their own implementation.\n\nThe first derived class is Bicycle, which overrides the drive() function with its own implementation that prints \"Driving a bicycle\".\n\nThe second derived class, Bicycle2, does not provide its own implementation of the drive() function and therefore uses the base class function, which prints \"Driving a TwoWheeledVehicle\"."},
{"slide_number": 13, "content": "\u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd (Polymorphism) is the ability in object-oriented programming to present the same interface for different underlying data types. In other words, it allows objects of different classes to be treated as if they were the same type of object. This is achieved through inheritance, where a subclass inherits methods and properties from its parent class and can also override them to provide its own implementation.\n\nIn the given code sample, the function `f` takes an argument of type `const TwoWheeledVehicle`, which is a base class. The `Bicycle` class and `Bicycle2` class are both subclasses that inherit from the `TwoWheeledVehicle` class. \n\nWhen the method `drive` is called on `bike`, which is an instance of the `Bicycle` class, it prints \"Driving a bicycle\" as expected. When the `f` function is called with the `bike` object as its argument, it also prints \"Driving a bicycle\" because the `Bicycle` class is a subclass of `TwoWheeledVehicle` and can be treated as if it were of type `TwoWheeledVehicle`.\n\nHowever, when `drive` is called on `bike2`, which is an instance of `Bicycle2`, it prints \"Driving a TwoWheeledVehicle\" because the implementation of `drive` in `Bicycle2` calls `TwoWheeledVehicle::drive()` explicitly. \n\nThis illustrates the concept of polymorphism in which different subclasses can have their own implementations of a method inherited from a base class."},
{"slide_number": 14, "content": "Pure virtual functions are functions in a base class that have no implementation and are declared with \"=0\" after the function declaration. These functions can be overridden by derived classes and are called \"pure\" because they have no implementation in the base class. \n\nAn abstract class is a class that contains at least one pure virtual function. Because the class has at least one unimplemented function, it cannot be instantiated. Its purpose is to provide an interface or template for derived classes to implement. \n\nWhen a class inherits from an abstract class, it must implement all of the pure virtual functions in the abstract class, either in the derived class itself or in a subclass of the derived class. If a subclass of the derived class is used to implement the pure virtual function, there is no need to declare the pure virtual function again in the intermediate class. The existence of the pure virtual function is passed on from the abstract base class."},
{"slide_number": 15, "content": "- Pure virtual: A pure virtual function is a virtual function that is marked with the \"= 0\" syntax at the end of its declaration in the base class. It means that the function has no implementation and must be overridden in any derived class. A class that contains at least one pure virtual function is called an abstract class.\n\n- Abstract class: An abstract class is a class that cannot be instantiated. It may only serve as a base class for other classes that inherit from it. Abstract classes often have pure virtual functions that define an interface that derived classes must implement.\n\n- TwoWheeledVehicle class: This is an abstract class that defines an interface for a two-wheeled vehicle. It has a pure virtual function called \"drive()\" that must be implemented in any derived class. This class cannot be instantiated on its own.\n\n- BicycleBase class: This is a derived class of TwoWheeledVehicle that doesn't add any new functionality, but just inherits the pure virtual function from its base class. It's marked as virtual, but the \"override\" keyword is not required and is just noise.\n\n- Bicycle class: This is a concrete class that inherits from BicycleBase and implements the \"drive()\" pure virtual function. It overrides the function with its own implementation that prints \"Driving a bicycle\" to the console. The \"override\" keyword is used to ensure that the function is actually overriding the base class function and not accidentally creating a new function with a similar name."},
{"slide_number": 16, "content": "1. Pure virtual - This refers to a virtual function that is declared in a base class and has no implementation in that base class. Any class that inherits from the base class and wants to instantiate an object must provide an implementation for the pure virtual function. \n\n2. Example - This refers to the code examples provided in the presentation to illustrate concepts and ideas. In this case, the code examples show the use of inheritance and virtual functions.\n\n3. \u05d4\u05de\u05e9\u05da class - This refers to a continued definition of a class. In the presentation, the continued definition of the ElectricBike class is shown.\n\n4. ElectricBike : public BicycleBase - This declares that the ElectricBike class inherits from the BicycleBase class and is a public member of it.\n\n5. void drive() const override - This defines a function in the ElectricBike class that overrides the drive() function declared in BicycleBase. The override keyword specifies that this function takes the place of the base class function.\n\n6. BestElectricBike : public ElectricBike - This declares that the BestElectricBike class inherits from the ElectricBike class and is a public member of it. Since it doesn't declare or define a new drive() function, it inherits the one defined in ElectricBike.\n\n7. MountainBike : public BicycleBase - This declares that the MountainBike class inherits from the BicycleBase class and is a public member of it. It is still an abstract class because it only inherits the pure virtual declaration of the drive() function from BicycleBase."},
{"slide_number": 17, "content": "- Pure virtual: This refers to a virtual function in a C++ class that has no implementation in the base class and must be implemented in any derived classes. It is used to create an interface that must be followed by all derived classes.\n\n- Example: This section provides examples of C++ code using classes and virtual functions.\n\n- \u05d4\u05de\u05e9\u05da (2): This likely means \"continued (2)\" in Hebrew or a similar language, indicating that there is additional information or code to follow.\n\n- Void f (const TwoWheeledVehicle& v): This is a C++ function that takes a constant reference to a TwoWheeledVehicle object as a parameter. The function then calls the object's drive() method.\n\n- Auto bike = Bicycle(): This creates an object of the Bicycle class and assigns it to the variable \"bike\". The object can then call its drive() method.\n\n- F(bike): This calls the function f() with the \"bike\" object as a parameter, causing it to execute the drive() method of the Bicycle class.\n\n- Auto bike2 = BestElectricBike(): This creates an object of the BestElectricBike class (which presumably derives from Bicycle) and assigns it to the variable \"bike2\". The object can then call its drive() method, which will call the implementation in the ElectricBike class.\n\n- Auto bike3 = MountainBike(): This attempts to create an object of the MountainBike class, but since it is an abstract class (presumably with pure virtual functions), it cannot be instantiated directly.\n\n- Void f(BicycleBase b): This function attempts to take an abstract BicycleBase class as a value parameter, but this is not allowed since copying the abstract class would create an object of that type."},
{"slide_number": 18, "content": "The topics are:\n\n1. \u05d3\u05d2\u05e9\u05d9\u05dd \u05dc\u05d9\u05e8\u05d5\u05e9\u05d4 (Emphasis on inheritance): This topic pertains to Object-Oriented Programming, where emphasis is given to the concept of inheritance. Inheritance allows a class to inherit properties and behavior from another class, thereby reducing redundancy and promoting code reuse. The emphasis on inheritance suggests that it is a crucial aspect to consider while designing classes and their relationships in an object-oriented program.\n\n2. \u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd (Polymorphism): This topic also belongs to Object-Oriented Programming and describes the ability of an object to take on multiple forms. Polymorphism allows the use of a variable of a superclass to represent objects of its subclasses. This concept promotes code reusability, flexibility, and extensibility.\n\n3. \u05de\u05ea\u05d9 \u05e0\u05e4\u05e8\u05d9\u05d3 \u05dc\u05de\u05d7\u05dc\u05e7\u05d5\u05ea? (When to separate into classes?): This topic deals with deciding when to split a program into classes. Separating code into classes can make the code easier to manage, understand, and maintain. The decision to separate depends on the complexity of the program, the level of abstraction required, and the functionality to be implemented."},
{"slide_number": 19, "content": "The topic discusses the decision-making process of whether to separate different classes or keep a single class with relevant data. If there is a difference in behavior between objects, it is better to create separate classes for them and implement different virtual functions accordingly. However, if the difference is only in a property, it is not necessary to separate the classes and can be maintained using a data member. It is also mentioned that using an \"if\" or \"switch\" statement to choose actions based on data member can be less efficient and harder to maintain. The decision to separate classes should be based on differences in behavior rather than differences in properties."},
{"slide_number": 20, "content": "The topics mentioned in this code snippet revolve around best practices in object-oriented programming and the use of inheritance and polymorphism. Specifically, the code illustrates the problem with having private data in a class, which can lead to inefficient code or difficulty in managing program modifications. \n\nThe example first shows a class called Enemy, which has a private boolean variable m_isSmart. The code within the move() method checks if this variable is true, and if so, computes a \"BFS\" action. Otherwise, it executes a random move. \n\nNext, the example introduces a better practice by creating an abstract class called EnemyBase, which contains a pure virtual move() function. This function will be overridden by any class that inherits from EnemyBase. \n\nFinally, the code demonstrates two subclasses - SmartEnemy and RandomEnemy - that both inherit from EnemyBase. Each of these subclasses implements its own version of the move() method, overriding the function defined in EnemyBase. SmartEnemy computes a \"BFS\" action, while RandomEnemy executes a random move. \n\nOverall, the code snippet highlights the importance of using inheritance and polymorphism in object-oriented programming as a way to improve code organization, flexibility, and efficiency. It also shows the potential issues with using private data in a class and how abstract classes and virtual functions can help to mitigate these issues."},
{"slide_number": 21, "content": "The topics mentioned in the bullet points are:\n\n1. \"When do we separate into departments?\" - This topic is not fully explained, but it appears to be a question regarding organizational structure or decision-making processes.\n\n2. \"Example\" - This bullet point likely refers to a specific example that was given or will be given to demonstrate a concept.\n\n3. \"Continuation\" - This bullet point suggests that the presentation or discussion will continue with additional information on the topic.\n\nThe code example given shows the difference between two classes, \"Bad!\" and \"Good!\", both of which contain sub-classes for different types of enemies. The \"Bad!\" class has separate move() functions for each type of enemy (FastEnemy and SlowEnemy), with hardcoded movement values. The \"Good!\" class, on the other hand, has a single move() function for all enemies, with the movement speed determined by a variable that is set in the constructor. This implementation allows for easier modification and flexibility in the behavior of the enemies. The use of \"override\" indicates that the move() function is a virtual function that has been redefined in the Enemy class."},
{"slide_number": 22, "content": "1. \u05d3\u05d2\u05e9\u05d9\u05dd \u05dc\u05d9\u05e8\u05d5\u05e9\u05d4 - \u05d6\u05d4\u05d5 \u05de\u05d5\u05e0\u05d7 \u05d4\u05de\u05ea\u05d0\u05e8 \u05d0\u05ea \u05db\u05da \u05e9\u05d9\u05e9\u05e0\u05dd \u05ea\u05db\u05d5\u05e0\u05d5\u05ea \u05d2\u05e0\u05d8\u05d9\u05d5\u05ea \u05d0\u05e9\u05e8 \u05e0\u05d9\u05ea\u05df \u05dc\u05d4\u05e2\u05d1\u05d9\u05e8 \u05d1\u05d9\u05df \u05d4\u05d5\u05e8\u05d9\u05dd \u05dc\u05d9\u05dc\u05d3\u05d9\u05dd, \u05db\u05da \u05e9\u05e0\u05d5\u05e6\u05e8\u05ea \u05d9\u05e8\u05d5\u05e9\u05d4 \u05d2\u05e0\u05d8\u05d9\u05ea. \u05d3\u05d2\u05e9\u05d9\u05dd \u05dc\u05d9\u05e8\u05d5\u05e9\u05d4 \u05de\u05e9\u05de\u05e2\u05d5\u05ea\u05dd \u05e9\u05dc \u05e1\u05d5\u05d2\u05d9 \u05d4\u05e0\u05ea\u05d5\u05e0\u05d9\u05dd \u05d4\u05d2\u05e0\u05d8\u05d9\u05d9\u05dd \u05d0\u05e9\u05e8 \u05e2\u05e9\u05d5\u05d9\u05d9\u05dd \u05dc\u05d4\u05e2\u05d1\u05d9\u05e8 \u05de\u05d0\u05d1\u05d0 \u05dc\u05d1\u05e0\u05d5, \u05d0\u05d7\u05ea \u05d4\u05d3\u05d5\u05d2\u05de\u05d0\u05d5\u05ea \u05d4\u05d8\u05d5\u05d1\u05d5\u05ea \u05dc\u05d3\u05d2\u05e9\u05d9\u05dd \u05dc\u05d9\u05e8\u05d5\u05e9\u05d4 \u05d4\u05dd \u05e4\u05e0\u05d5\u05d8\u05d9\u05e4\u05d9\u05dd.\n\n2. \u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd - \u05d4\u05d5\u05d0 \u05de\u05d5\u05e0\u05d7 \u05d4\u05de\u05ea\u05d0\u05e8 \u05d0\u05ea \u05e2\u05de\u05d3\u05ea \u05d4\u05d8\u05d5\u05d5\u05d7 \u05d4\u05e8\u05d7\u05d1 \u05e9\u05dc \u05d4\u05ea\u05db\u05d5\u05e0\u05d5\u05ea \u05d4\u05d2\u05e0\u05d8\u05d9\u05d5\u05ea \u05d1\u05ea\u05d5\u05da \u05d4\u05de\u05d9\u05df \u05d4\u05d0\u05e0\u05d5\u05e9\u05d9, \u05db\u05dc\u05d5\u05de\u05e8, \u05d4\u05e2\u05d5\u05d1\u05d3\u05d4 \u05e9\u05d0\u05e0\u05e9\u05d9\u05dd \u05e9\u05d5\u05e0\u05d9\u05dd \u05e2\u05e9\u05d5\u05d9\u05d9\u05dd \u05dc\u05d4\u05e4\u05d9\u05e7 \u05ea\u05d5\u05e6\u05d0\u05d5\u05ea \u05d2\u05e0\u05d8\u05d9\u05d5\u05ea \u05e9\u05d5\u05e0\u05d5\u05ea \u05e2\u05d1\u05d5\u05e8 \u05ea\u05db\u05d5\u05e0\u05d5\u05ea \u05de\u05e1\u05d5\u05d9\u05de\u05d5\u05ea. \n\n3. \u05de\u05ea\u05d9 \u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd \u05e2\u05d5\u05d1\u05d3? \u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd \u05e2\u05d5\u05d1\u05d3 \u05db\u05d0\u05e9\u05e8 \u05d9\u05e9\u05e0\u05dd \u05e9\u05d5\u05e0\u05d9 \u05d2\u05e0\u05d8\u05d9\u05d9\u05dd \u05d1\u05e0\u05e7\u05d5\u05d3\u05d5\u05ea \u05de\u05e1\u05d5\u05d9\u05de\u05d5\u05ea \u05e9\u05dc \u05d4\u05e7\u05d5\u05d3 \u05d4\u05d2\u05e0\u05d8\u05d9, \u05d5\u05d0\u05dc\u05d5 \u05de\u05d5\u05e4\u05d9\u05e2\u05d9\u05dd \u05dc\u05e2\u05ea\u05d9\u05dd \u05ea\u05db\u05d5\u05e0\u05d5\u05ea \u05d2\u05e0\u05d8"},
{"slide_number": 23, "content": "The presentation discusses the use of polymorphism in object-oriented programming. In order to achieve polymorphic behavior in functions, it is necessary to use references or pointers to objects whose type is that of a base class. If an object of a subclass is used directly, the behavior may not be polymorphic. This is because the type is known in advance and there is no need for polymorphic behavior.\n\nIf a parameter of a function is given by value, rather than as a reference or pointer, the behavior will not be polymorphic. This is because copying the object only copies the elements of the base class, leading to slicing - meaning only the base class is copied. To avoid these issues, it is important to use references or pointers to objects, and to ensure that all objects used in functions are of the same type or subclass. This will allow for proper polymorphic behavior and ensure that the correct override function is called."},
{"slide_number": 24, "content": "1. \u05d3\u05d2\u05e9\u05d9\u05dd \u05dc\u05d9\u05e8\u05d5\u05e9\u05d4 (emphasis on inheritance): This topic refers to programming concepts related to object-oriented inheritance, which involves creating new classes by inheriting properties and methods from existing classes. Emphasis on inheritance means focusing on the use and implementation of inheritance in a program, including strategies for designing inheritance hierarchies and dealing with issues such as inheritance conflicts.\n\n2. \u05e4\u05d5\u05dc\u05d9\u05de\u05d5\u05e8\u05e4\u05d9\u05d6\u05dd (polymorphism): This refers to a programming concept where objects of different classes can be used interchangeably, allowing for flexible and modular code. Polymorphism is usually achieved through inheritance and interfaces, which provide a way for different classes to share common behavior.\n\n3. \u05e9\u05d9\u05de\u05d5\u05e9 \u05d1\u05de\u05d9\u05dc\u05d4 override (use of the keyword \"override\"): This topic refers to a specific aspect of polymorphism in object-oriented programming, where a subclass can override a method implementation inherited from a superclass. This allows for more specialized behavior in the subclass while still maintaining the structure and functionality of the superclass. The \"override\" keyword is used to signify that a method is intended to override a superclass method."},
{"slide_number": 25, "content": "1. Defining override in a derived class: When we define an override for a virtual function in a derived class, we need to add the keyword \"override\" at the end of the function declaration. If we don't add this keyword, the code will still compile and behave polymorphically. However, the compiler will compare the signature of the virtual function in the base class with the functions in the derived classes to determine if there is an override. \n\n2. The mechanism for override prior to C++11: Prior to C++11, the only mechanism for override was based on the comparison of function signatures. The significant disadvantage of this mechanism was that if we made any changes to the signature, it would no longer be an override. However, the compiler would not be able to detect this issue and thus not provide any warning.\n\n3. The addition of \"override\" in C++11: In C++11, the keyword \"override\" was introduced so that we could explicitly indicate that we intended to override a virtual function in a base class. When this keyword is added, the compiler will provide an error at compile-time if the function in question does not actually override a virtual function in the base class.\n\nIt is recommended to use the \"override\" keyword whenever we intend to override a virtual function in a derived class."},
{"slide_number": 26, "content": "Topic: Virtual D-tor\n- A virtual D-tor is a virtual design tool that allows designers to create and showcase their models in a simulated environment.\n- It includes various features like image rendering, 3D modeling, and animation, which help designers to visualize their designs.\n- Virtual D-tor software can be used in various industries like architecture, engineering, construction, gaming, and entertainment.\n- It can be used to create interactive and immersive experiences for the audience, which enhances the overall design.\n- A virtual D-tor allows the designer to make changes and adjustments to their design in real-time, saving valuable time and resources.\n- It also enables collaboration between clients, stakeholders, and design teams, allowing remote stakeholders to be part of the design process."},
{"slide_number": 27, "content": "In this presentation, there are several topics related to defining base classes with virtual functions and destructors. The first point is that when we define a base class with virtual functions, it is important to also define a virtual destructor, even if its implementation is empty. The recommended way to do this is by using \"= default\" after the destructor's declaration. The reason for this is that when objects of derived classes are deleted through a pointer of the base class, we need to ensure that the correct destructor is called. \n\nThe second point is that if all destructors in the hierarchy are empty, they should still be defined as virtual. This is because all data members of the derived classes will be destroyed in the derived class's destructor, and if it is not defined as virtual, only the base class's destructor will be called. \n\nFinally, it is important to use polymorphism when deleting objects through a pointer of the base class, to ensure that the correct destructor is called. Overall, these guidelines improve the safety and correctness of the code when working with polymorphism and inheritance in C++."},
{"slide_number": 28, "content": "- ABC stands for Abstract Base Class and is a concept in object-oriented programming (OOP).\n- An abstract base class is a class that cannot be instantiated (meaning objects cannot be created from it) but serves as a blueprint for other classes that can be instantiated.\n- The purpose of an abstract base class is to provide a common interface or set of methods that its subclasses must implement, ensuring uniform behavior across different classes.\n- Any class that inherits from an abstract base class must implement all of its abstract methods or it will also be considered an abstract class.\n- Abstract base classes can be used to enforce specific behaviors or requirements in the classes that inherit from them, improving the overall structure and reliability of a program."},
{"slide_number": 29, "content": "The presentation discusses the importance of avoiding inheritance from concrete classes (classes that are not abstract) in C++. The speaker explains that although the language allows us to do so, it is better to avoid it. Instead, the base class, especially if it contains virtual functions, should be abstract. The presenter gives an example of a bad implementation where a derived class inherits from a concrete base class.\n\nThe second topic discussed is that every base class, especially intermediate classes, should be abstract if it contains virtual functions. The presenter gives an example of a good implementation where a derived class inherits from an abstract base class.\n\nLastly, the presentation emphasizes that only the leaves of inheritance trees should be concrete classes, while all other intermediate classes and base classes should be abstract (ABC - Abstract Base Class). ABC provides a clear interface for other developers to implement their derived classes while keeping the code modular and easy to modify."},
{"slide_number": 30, "content": "The text discusses two reasons for using \"by-value\" instead of a pointer or a reference when passing base class objects as parameters in C++ programming language. The first reason is to prevent accidentally receiving a parameter by reference or pointer, which can cause slicing and other errors. By receiving a parameter by value, a copy of the object is created, and it is impossible to create an object from an abstract class, preventing an error. The second reason is more complex, and it relates to defining an assignment operator for a non-abstract base class, which is impossible without risking errors and bugs in the program. The recommendation is to always make non-leaf classes abstract base classes (ABC)."},
{"slide_number": 31, "content": "Topic: Hiding\nExplanation: Hiding is a programming concept that refers to the practice of restricting access to certain parts of a program or data. This is done to prevent unintended modification or tampering, and also to make programs more secure and efficient.\n\nTopic: \u05d4\u05ea\u05e0\u05d4\u05d2\u05d5\u05ea \u05e2\u05dd overload set\nExplanation: \u05d4\u05ea\u05e0\u05d4\u05d2\u05d5\u05ea \u05e2\u05dd overload set is a Hebrew term that refers to the behavior of a program when dealing with an overload set. An overload set is a collection of functions or methods that have the same name, but different parameters. When a program encounters an overload set, it must determine which function or method to use based on the type and number of arguments passed to it. Proper handling of overload sets is important for ensuring that programs behave correctly and produce the desired results."},
{"slide_number": 32, "content": "1. Hiding: This concept refers to a situation in which a subclass has a member with the same name as a member in its parent class, causing the parent's member to be hidden or inaccessible in the subclass.\n\n2. Inheritance and Overload Set: Sometimes it can be useful to define a specific function in a base class and then add overloads for it in the derived class. It's important to note that this concept relates to overloading, not overriding, of a virtual function within a derived class.\n\n3. Virtual Function Overriding and Overloading: In some cases, a virtual function will have both an override function in a derived class as well as multiple overloads within that same derived class. \n\n4. Example Code: The code snippet provided shows a base class called \"MyBase\" with a function called \"f\" that takes an integer parameter. The derived class \"Derived\" inherits from MyBase and has a function \"f\" that takes a reference to MyBase. When an instance of Derived is created and the \"f\" function is called with parameters (d) and (42), the second call will result in a compilation error because there is no overload for \"f\" that takes an integer parameter."},
{"slide_number": 33, "content": "The presentation covers two topics: hiding and overload set. Hiding refers to a situation where a function defined in a derived class hides a function with the same name in the base class. This means that only the new function is available for use, and the old one is hidden. Overload set, on the other hand, refers to situations where two functions have the same name but different parameters. The compiler will choose the most appropriate function to use based on the context in which the name is used and the parameters that have been provided. The presentation also provides an example of scope and name hiding, where the same name is used in different scopes to refer to different things, but the compiler is able to identify the most appropriate one to use based on the context."},
{"slide_number": 34, "content": "1. Hiding: In object-oriented programming, hiding refers to the ability to hide the implementation details of a class or its members from the outside world. This is done by making them private or protected, so that only the class and its derived classes have access to them.\n\n2. Overload set: In C++, functions can have the same name as long as they differ in their parameter types or number. This is known as function overloading. When the compiler encounters multiple functions with the same name, it creates an overload set, which is a collection of all the functions with that name. The compiler then decides which function to call based on the arguments passed to it.\n\n3. Scope and inheritance: When a function is called, the compiler looks for it in the current scope and then in the scopes of its base classes. If the function is overloaded, the compiler selects the appropriate one based on the arguments passed to it. If a derived class defines an overloaded function with the same name as a function in its base class, the functions in the base class become hidden and are not part of the overload set."},
{"slide_number": 35, "content": "1. Hiding - this refers to a situation in which a member function or variable in a derived class has the same name as a member function or variable in the base class, causing the latter to be hidden from the derived class.\n\n2. \u05d9\u05e8\u05d5\u05e9\u05d4 \u05d5-overload set - this refers to inheritance and functions that are overloaded, or have multiple versions with different parameters.\n\n3. \u05e4\u05ea\u05e8\u05d5\u05df \u05d5\u05de\u05d4 \u05d0\u05dd \u05e0\u05e6\u05d8\u05e8\u05da \u05e9\u05d7\u05dc\u05e7 \u05de\u05d4\u05beoverload set \u05d9\u05d4\u05d9\u05d4 \u05d1\u05de\u05d7\u05dc\u05e7\u05ea \u05d4\u05d1\u05e1\u05d9\u05e1 \u05d5\u05d7\u05dc\u05e7 \u05d1\u05de\u05d7\u05dc\u05e7\u05d4 \u05d4\u05d9\u05d5\u05e8\u05e9\u05ea? \u05de\u05e7\u05d5\u05dd \u05db\u05d6\u05d4 \u05d4\u05d5\u05d0 double dispatch - this refers to a situation in which there is a need for part of an overload set to be in the base class and part to be in the derived class. This can be achieved using a technique called double dispatch.\n\n4. \u05d4\u05e8\u05d1\u05d4 \u05de\u05d4\u05e4\u05d5\u05e0\u05e7\u05e6\u05d9\u05d5\u05ea \u05db\u05d3\u05d0\u05d9 \u05dc\u05de\u05de\u05e9 \u05d1\u05de\u05d7\u05dc\u05e7\u05d5\u05ea \u05d4\u05d1\u05d9\u05e0\u05d9\u05d9\u05dd \u05dc\u05d3\u05d5\u05d2\u05de\u05d4: \u05d0\u05ea \u05db\u05dc \u05d4\u05d4\u05ea\u05e0\u05d2\u05e9\u05d5\u05d9\u05d5\u05ea \u05e2\u05dd \u05d0\u05d5\u05d1\u05d9\u05d9\u05e7\u05d8 \u05e1\u05d8\u05d8\u05d9, \u05db\u05d3\u05d0\u05d9 \u05dc\u05de\u05de\u05e9 \u05d1\u05de\u05d7\u05dc\u05e7\u05ea \u05d4\u05d1\u05d9\u05e0\u05d9\u05d9\u05dd \u05e9\u05d4\u05d9\u05d0 \u05d1\u05e1\u05d9\u05e1 \u05dc\u05db\u05dc \u05d4\u05d0\u05d5\u05d1\u05d9\u05d9\u05e7\u05d8\u05d9\u05dd \u05d4\u05e1\u05d8\u05d8\u05d9\u05d9\u05dd - this suggests that many functions are better implemented in intermediate classes. For example, dealing with collisions with a static object is best implemented in an intermediate class that serves as the base for all static objects.\n\n5. \u05db\u05d9 \u05e2\u05d1\u05d5\u05e8 \u05db\u05d5\u05dc\u05dd \u05d4\u05de\u05d9\u05de\u05d5\u05e9 \u05d9\u05d4\u05d9\u05d4 \u05e4\u05e9\u05d5\u05d8 \u05e8\u05d9\u05e7 \u05d4\u05e4\u05ea\u05e8\u05d5\u05df \u05d4\u05d5\u05d0 \"\u05dc\u05d9\u05d9\u05d1\u05d0\" \u05d0\u05ea \u05d4\u05e9\u05de\u05d5\u05ea \u05d4\u05e8\u05dc\u05d5\u05d5\u05e0\u05d8\u05d9\u05d9\u05dd \u05de-scope \u05d0\u05d7\u05d3 \u05dc\u05e9\u05e0\u05d9, \u05e9\u05db\u05dc \u05d4\u05e9\u05de\u05d5\u05ea \u05de\u05de\u05d7\u05dc\u05e7\u05ea \u05d4\u05d1\u05e1\u05d9\u05e1 \u05d9\u05d4\u05d9\u05d5 \u05d6\u05de\u05d9\u05e0\u05d9\u05dd"},
{"slide_number": 36, "content": "RTTI stands for Run-Time Type Identification, which is a feature in programming languages such as C++ and Java. It allows developers to determine the type of an object or variable at runtime, rather than at compile time. \n\nThis feature is particularly useful when working with polymorphism, which allows objects of different types to be treated as if they were the same type. Without RTTI, it would be difficult or impossible to determine the types of these objects at runtime, which could cause errors or unexpected behavior.\n\nRTTI allows programmers to perform type checking and type casting at runtime, which can help to ensure the correctness and safety of their code. It is also commonly used in the implementation of dynamic binding, which allows methods to be resolved at runtime based on the type of the object that they are called on."},
{"slide_number": 37, "content": "RTTI stands for Runtime Type Identification, which refers to the ability to identify the dynamic type of an object during runtime. The language provides two tools for this purpose, namely typeid and dynamic_cast. While both tools help in identifying the type of an object, there is a difference between them which will be discussed later.\n\nHowever, it is important to note that there is a risk of overusing these tools instead of relying on polymorphism, which is a fundamental aspect of object-oriented programming. Therefore, it is crucial to understand when to use RTTI tools and when polymorphism is sufficient."},
{"slide_number": 38, "content": "The topic being discussed here is the difference between the use of `typeid` and `dynamic_cast` in C++. `typeid` is useful for finding an exact type while `dynamic_cast` can give a positive response even when checking base classes of the object. The code example given defines classes `A`, `B`, `C`, and `D` and a function `f()` that creates an object of class `C` and assigns it to a pointer of type `A*`. The `if` statements in the function use `dynamic_cast` and `typeid` to check the actual type of the object and print out the appropriate output. The function causes memory leakage and when executed, will print `B*C*C`. The concept being discussed is RTTI (Run-Time Type Information), which is used to retrieve information about an object's type at runtime."},
{"slide_number": 39, "content": "RTTI, or Run-Time Type Identification, is a feature in C++ that allows you to determine an object's type during runtime. Two commonly used tools for RTTI are `dynamic_cast` and `typeid`. `dynamic_cast` is used to perform safe downcasting of polymorphic objects, which means objects that contain at least one virtual function. However, `dynamic_cast` cannot be used if any of the types involved are not polymorphic. \n\nIn contrast, `typeid` can be used on both polymorphic and non-polymorphic types during compilation time. However, when used on a pointer, it will return the type of the pointer rather than the type of the object it points to. This can lead to confusion and mistakes, so it's important to use it carefully. \n\nIf a `dynamic_cast` fails, it returns a `nullptr` for pointers or throws an exception for references. However, if `typeid` is used on a null pointer, it will cause undefined behavior, which could lead to runtime errors or exceptions. Therefore, it's important to handle exceptions properly when using RTTI in C++."},
{"slide_number": 40, "content": "\u05d9\u05e8\u05d5\u05e9\u05d4 (Inheritance):\n- Inheritance is the ability of classes to be based on other classes.\n- A subclass (child class) inherits properties and methods from its parent class. \n- This allows for code reuse and creates a hierarchy of classes.\n\nAccess Modifiers:\n- Access modifiers are keywords that determine the visibility of class members (properties, methods, fields).\n- The four access modifiers are: public, private, protected, and internal.\n- Public: The member is accessible to any code in the program.\n- Private: The member is only accessible within the class it is declared in.\n- Protected: The member is accessible within the class it is defined in and any subclasses.\n- Internal: The member is accessible within the same assembly (a group of related classes) but not outside of it.\n\nOverall, inheritance and access modifiers are important concepts in object-oriented programming as they provide structure and control over the visibility of class members."},
{"slide_number": 41, "content": "1. \u05d9\u05e8\u05d5\u05e9\u05d4 (Inheritance): \nInheritance is a mechanism in which one class acquires the properties and behaviors of another class. In this context, the derived class (also called the \"child\" class) acquires the properties and methods of the base class (or \"parent\" class). \n\n2. Access Modifiers (\u05de\u05d5\u05d3\u05d9\u05e4\u05d9\u05d9\u05e8\u05d9 \u05d2\u05d9\u05e9\u05d4):\nAccess modifiers are keywords that determine the visibility and accessibility of a class's members (fields, methods, properties, etc.) to the outside world. \n\n3. \"public\" Access Modifier:\nThe \"public\" access modifier means that the member is visible and accessible to all parts of the program. When used in the context of inheritance, it means that the child class has full access to the public members of the base class. \n\n4. Example:\nIn the example given (\"class B : public A {};\"), it means that class B inherits all the public members of class A. This allows class B to access and use those members in addition to any members it defines itself. \n\n5. \"protected\" and \"private\" Access Modifiers:\nIf \"protected\" or \"private\" access modifiers are used instead of \"public\" in the inheritance declaration, it means that the derived class (or any other classes) cannot access those members. Protected members can be accessed within the class and its derived classes, while private members can only be accessed within the class itself."},
{"slide_number": 42, "content": "In object-oriented programming, inheritance and access modifiers are important concepts. Inheritance allows a subclass to inherit properties and methods from its superclass. Sometimes subclasses are only used for internal implementation and not intended for public use, so inheritance with a non-public access modifier can be useful in these cases. However, this is uncommon and most of the time inheritance should be declared with a public access modifier. \n\nAccess modifiers refer to the level of access that other classes have to the members of a class. When using inheritance with a public access modifier, we can only access public members of the base class, not private members. However, inheritance with a protected access modifier allows the current class and its subclasses to access public and protected members of the base class. This can be useful for enforcing restrictions on access to certain members."},
{"slide_number": 43, "content": "Double Dispatch is a design pattern used in object-oriented programming, where the call to a method is determined not only by the method name and the arguments passed but also by the type of the object that the method is called on. In other words, the method is dynamically dispatched based on both the runtime types of two objects.\n\nIn a language that supports single dispatch, the method that gets invoked depends on the type of the object that the method is called on. However, when we add a second parameter to the method call, the decision on which method is called gets more complicated. With double dispatch, we enable the method that gets invoked to be determined by the runtime types of both the objects involved in the method call.\n\nIn simpler terms, Double Dispatch is a way to determine the specific method call based on the runtime types of two objects involved in the method call. This pattern tends to maintain loose coupling between objects, and it promotes extensibility and flexibility in object-oriented design."},
{"slide_number": 44, "content": "Double dispatch is a design pattern used in object-oriented programming. It is used to handle collisions between different objects in a way that is specific to each object type. For example, if Pac-man collides with a wall, a ghost, or a cookie, the way the collision is handled will be different in each case. The goal is to make the handling of collisions simple and object-oriented, using polymorphism. This means that instead of holding objects with a pointer to their base class, we define the collision handling function as a virtual function. We can then implement it in each subclass according to its specific needs. This allows us to handle collisions in a way that is specific to the object type, and avoids the need for a lot of if/else statements."},
{"slide_number": 45, "content": "Double dispatch is a problem that arises when a function is only virtual in relation to the object on which it is called, not in relation to its parameters. However, behavior should be polymorphic in relation to both objects that participate in the collision. The language does not naturally provide us with the ability to do so. The parameter we pass will be received in the function according to its static type, which is known at compile time (in this case, according to the base class) and not according to its dynamic type, which will be known only at runtime."},
{"slide_number": 46, "content": "Double dispatch is a design pattern used in object-oriented programming where the method to be called is determined at runtime based on the types of two objects involved in a method call. It involves multiple polymorphic method calls, resulting in increased flexibility and extensibility.\n\nThe problem that double dispatch solves is the inability to have different behaviors for the same method depending on the types of both objects involved in a method call. In traditional single dispatch, the method called is determined solely by the type of one object, not both.\n\nIn the given example, we have a class called GameObject which has a method called collidesWith that takes another GameObject object as an argument. The collidesWith method calculates whether the location of the current object intersects with the location of the argument object and returns a boolean value. \n\nThe GameObject class also has two virtual methods called handleCollision which are not implemented in the base class, only declared. One takes a GameObject reference as input and the other takes a Wall reference.\n\nThe Monster class inherits from GameObject and overrides both handleCollision methods. This allows it to have a different behavior when colliding with another GameObject versus colliding with a Wall object. \n\nBy utilizing double dispatch in the handleCollision method, the proper handleCollision function call is determined at runtime based on the types of both objects involved in the collision. This allows for more flexible and extensible code as new object types can be added without modifying the existing code."},
{"slide_number": 47, "content": "Double dispatch is a design pattern that helps to solve problems related to the runtime behavior of software objects. One example of such a problem is collision detection and handling in a game. The code snippet given shows how an std::vector of std::unique_ptr to GameObjects is being used to handle collisions between objects. \n\nIf m_objects[i] points to an object of type Monster and m_objects[j] points to an object of type Wall, the handleCollision() function will be called based on the overload that takes a GameObject argument. This is because there is no polymorphism for function parameters, and the type of the argument is determined at compilation time.\n\nTo solve this problem, the double dispatch technique can be employed. It involves creating separate overload functions for each combination of object types that need to collide. This allows the correct function to be chosen at runtime, depending on the types of both objects involved in the collision."},
{"slide_number": 48, "content": "Double dispatch is a solution to handle collisions between two objects in an object-oriented programming language. It allows us to determine the exact types of both objects involved in the collision using virtual function calls. Instead of using a single virtual function call, which would only solve for one of the objects involved, double dispatch uses two virtual function calls, one for each object involved in the collision. This allows us to accurately determine the specific types of both objects and handle the collision appropriately. \n\nIn the example shown, the virtual function \"handleCollision\" is called on the Monster object, passing in the GameObject object as a reference. This first virtual function call brings us to the specific implementation of handleCollision(). We then \"swap roles\" between the two objects and call the function again, this time passing in the reference to the Monster object, whose type is already known. The overloaded version of the function that is called will be the one that accepts the Monster object type, allowing us to perform the necessary collision handling for Monsters."},
]